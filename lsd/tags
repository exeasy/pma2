!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
ACCESS_ETH	lsd_if.h	/^    ACCESS_ETH = 0,$/;"	e	enum:eth_type
ACCESS_LSA_CT_PER_PAK	lsd_exchange.h	8;"	d
ACK_OVER_TIME	lsd_exchange.h	5;"	d
ACK_OVER_TIME	lsd_flood.h	9;"	d
ACLOCAL	Makefile	/^ACLOCAL = ${SHELL} \/home\/macro\/workspace\/pma\/missing aclocal-1.14$/;"	m
ACLOCAL_M4	Makefile	/^ACLOCAL_M4 = $(top_srcdir)\/aclocal.m4$/;"	m
ALREADY_EXISTS_ERR	lsd_cmn.h	9;"	d
AMTAR	Makefile	/^AMTAR = $${TAR-tar}$/;"	m
AM_DEFAULT_VERBOSITY	Makefile	/^AM_DEFAULT_VERBOSITY = 1$/;"	m
AM_V_AR	Makefile	/^AM_V_AR = $(am__v_AR_$(V))$/;"	m
AM_V_CC	Makefile	/^AM_V_CC = $(am__v_CC_$(V))$/;"	m
AM_V_CCLD	Makefile	/^AM_V_CCLD = $(am__v_CCLD_$(V))$/;"	m
AM_V_GEN	Makefile	/^AM_V_GEN = $(am__v_GEN_$(V))$/;"	m
AM_V_P	Makefile	/^AM_V_P = $(am__v_P_$(V))$/;"	m
AM_V_at	Makefile	/^AM_V_at = $(am__v_at_$(V))$/;"	m
AM_V_lt	Makefile	/^AM_V_lt = $(am__v_lt_$(V))$/;"	m
AR	Makefile	/^AR = ar$/;"	m
ARFLAGS	Makefile	/^ARFLAGS = cru$/;"	m
ASSERT_ERR	lsd_cmn.h	13;"	d
AUTOCONF	Makefile	/^AUTOCONF = ${SHELL} \/home\/macro\/workspace\/pma\/missing autoconf$/;"	m
AUTOHEADER	Makefile	/^AUTOHEADER = ${SHELL} \/home\/macro\/workspace\/pma\/missing autoheader$/;"	m
AUTOMAKE	Makefile	/^AUTOMAKE = ${SHELL} \/home\/macro\/workspace\/pma\/missing automake-1.14$/;"	m
AWK	Makefile	/^AWK = gawk$/;"	m
BACKBONE_ETH	lsd_if.h	/^    BACKBONE_ETH = 1};$/;"	e	enum:eth_type
CC	Makefile	/^CC = gcc$/;"	m
CCDEPMODE	Makefile	/^CCDEPMODE = depmode=gcc3$/;"	m
CCLD	Makefile	/^CCLD = $(CC)$/;"	m
CFLAGS	Makefile	/^CFLAGS = -g -O2$/;"	m
COMPILE	Makefile	/^COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \\$/;"	m
CONFIG_CLEAN_FILES	Makefile	/^CONFIG_CLEAN_FILES =$/;"	m
CONFIG_CLEAN_VPATH_FILES	Makefile	/^CONFIG_CLEAN_VPATH_FILES =$/;"	m
CONFIG_HEADER	Makefile	/^CONFIG_HEADER = $(top_builddir)\/config.h$/;"	m
CONTAINER_EMPTY_ERR	lsd_cmn.h	12;"	d
CPP	Makefile	/^CPP = gcc -E$/;"	m
CPPFLAGS	Makefile	/^CPPFLAGS = $/;"	m
CTAGS	Makefile	/^CTAGS = ctags$/;"	m
CYGPATH_W	Makefile	/^CYGPATH_W = echo$/;"	m
DEFAULT_INCLUDES	Makefile	/^DEFAULT_INCLUDES = -I. -I$(top_builddir)$/;"	m
DEFS	Makefile	/^DEFS = -DHAVE_CONFIG_H$/;"	m
DEPDIR	Makefile	/^DEPDIR = .deps$/;"	m
DISTFILES	Makefile	/^DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)$/;"	m
DIST_COMMON	Makefile	/^DIST_COMMON = $(srcdir)\/Makefile.in $(srcdir)\/Makefile.am \\$/;"	m
DIST_SOURCES	Makefile	/^DIST_SOURCES = $(libpmalsd_a_SOURCES)$/;"	m
DLLTOOL	Makefile	/^DLLTOOL = false$/;"	m
DSYMUTIL	Makefile	/^DSYMUTIL = $/;"	m
DUMPBIN	Makefile	/^DUMPBIN = $/;"	m
ECHO_C	Makefile	/^ECHO_C = $/;"	m
ECHO_N	Makefile	/^ECHO_N = -n$/;"	m
ECHO_T	Makefile	/^ECHO_T = $/;"	m
EGREP	Makefile	/^EGREP = \/usr\/bin\/grep -E$/;"	m
ETAGS	Makefile	/^ETAGS = etags$/;"	m
ETH_DOWN	lsd_if.h	/^    ETH_DOWN = 0,$/;"	e	enum:eth_state
ETH_UP	lsd_if.h	/^    ETH_UP = 1 };$/;"	e	enum:eth_state
EXCHANGE_PKG_TYPE_ACK	lsd_exchange.h	40;"	d
EXCHANGE_PKG_TYPE_LINKS_STATE	lsd_exchange.h	38;"	d
EXCHANGE_PKG_TYPE_NO_DATA	lsd_exchange.h	39;"	d
EXCHANGE_STATE_RCV_END	lsd_exchange.h	/^	EXCHANGE_STATE_RCV_END$/;"	e	enum:exchange_rcv_state
EXCHANGE_STATE_RCV_TREMINATED	lsd_exchange.h	/^	EXCHANGE_STATE_RCV_TREMINATED = 0,$/;"	e	enum:exchange_rcv_state
EXCHANGE_STATE_RCV_WAITING	lsd_exchange.h	/^	EXCHANGE_STATE_RCV_WAITING,$/;"	e	enum:exchange_rcv_state
EXCHANGE_STATE_SEND_END	lsd_exchange.h	/^	EXCHANGE_STATE_SEND_END$/;"	e	enum:exchange_send_state
EXCHANGE_STATE_SEND_TERMINATED	lsd_exchange.h	/^	EXCHANGE_STATE_SEND_TERMINATED = 0,$/;"	e	enum:exchange_send_state
EXCHANGE_STATE_SEND_WAITING	lsd_exchange.h	/^	EXCHANGE_STATE_SEND_WAITING,$/;"	e	enum:exchange_send_state
EXEEXT	Makefile	/^EXEEXT = $/;"	m
FGREP	Makefile	/^FGREP = \/usr\/bin\/grep -F$/;"	m
FLOOD_ACK_WAITING	lsd_flood.h	/^	FLOOD_READY, FLOOD_BUSY, FLOOD_ACK_WAITING, FLOOD_TERMINATED$/;"	e	enum:flood_state
FLOOD_BUFFER_TIME	lsd_flood.c	13;"	d	file:
FLOOD_BUSY	lsd_flood.h	/^	FLOOD_READY, FLOOD_BUSY, FLOOD_ACK_WAITING, FLOOD_TERMINATED$/;"	e	enum:flood_state
FLOOD_PKG_TYPE_ACK	lsd_flood.h	7;"	d
FLOOD_PKG_TYPE_LSA	lsd_flood.h	6;"	d
FLOOD_READY	lsd_flood.h	/^	FLOOD_READY, FLOOD_BUSY, FLOOD_ACK_WAITING, FLOOD_TERMINATED$/;"	e	enum:flood_state
FLOOD_TERMINATED	lsd_flood.h	/^	FLOOD_READY, FLOOD_BUSY, FLOOD_ACK_WAITING, FLOOD_TERMINATED$/;"	e	enum:flood_state
GREP	Makefile	/^GREP = \/usr\/bin\/grep$/;"	m
HEADERS	Makefile	/^HEADERS = $(noinst_HEADERS)$/;"	m
HIGH_PRIORITY_DETECTION	lsd_hello.h	/^	HIGH_PRIORITY_DETECTION,$/;"	e	enum:priority_type
H_DEAD_VAL	lsd_hello.h	11;"	d
H_HELLO_VAL	lsd_hello.h	9;"	d
IC_H_PORT	lsd_socket.h	14;"	d
IC_L_PORT	lsd_socket.h	15;"	d
IC_MESSAGE_TYPE_EXCHANGE	lsd_cmn.h	21;"	d
IC_MESSAGE_TYPE_EXCHANGE	lsd_socket.h	9;"	d
IC_MESSAGE_TYPE_FLOOD	lsd_cmn.h	22;"	d
IC_MESSAGE_TYPE_FLOOD	lsd_socket.h	10;"	d
IC_MESSAGE_TYPE_HELLO_H	lsd_cmn.h	19;"	d
IC_MESSAGE_TYPE_HELLO_H	lsd_socket.h	7;"	d
IC_MESSAGE_TYPE_HELLO_L	lsd_cmn.h	20;"	d
IC_MESSAGE_TYPE_HELLO_L	lsd_socket.h	8;"	d
IC_MESSAGE_TYPE_LFA_ADVERTISE	lsd_cmn.h	24;"	d
IC_MESSAGE_TYPE_LFA_ADVERTISE	lsd_socket.h	12;"	d
IC_MESSAGE_TYPE_LFA_CHANGE	lsd_cmn.h	23;"	d
IC_MESSAGE_TYPE_LFA_CHANGE	lsd_socket.h	11;"	d
IFNAMSIZ	lsd_if.h	4;"	d
ILLEGAL_ARGS_ERR	lsd_cmn.h	14;"	d
INSTALL	Makefile	/^INSTALL = \/usr\/bin\/install -c$/;"	m
INSTALL_DATA	Makefile	/^INSTALL_DATA = ${INSTALL} -m 644$/;"	m
INSTALL_HEADER	Makefile	/^INSTALL_HEADER = $(INSTALL_DATA)$/;"	m
INSTALL_PROGRAM	Makefile	/^INSTALL_PROGRAM = ${INSTALL}$/;"	m
INSTALL_SCRIPT	Makefile	/^INSTALL_SCRIPT = ${INSTALL}$/;"	m
INSTALL_STRIP_PROGRAM	Makefile	/^INSTALL_STRIP_PROGRAM = $(install_sh) -c -s$/;"	m
IO_ERR	lsd_cmn.h	15;"	d
LD	Makefile	/^LD = \/usr\/bin\/ld$/;"	m
LDFLAGS	Makefile	/^LDFLAGS = $/;"	m
LIBOBJS	Makefile	/^LIBOBJS = $/;"	m
LIBRARIES	Makefile	/^LIBRARIES = $(noinst_LIBRARIES)$/;"	m
LIBS	Makefile	/^LIBS = -lxml2 -lnetsnmp -ldl -lpthread $/;"	m
LIBTOOL	Makefile	/^LIBTOOL = $(SHELL) $(top_builddir)\/libtool$/;"	m
LIB_SNMP_INCLUDE	Makefile	/^LIB_SNMP_INCLUDE = \/usr\/local\/snmp\/include\/$/;"	m
LIB_SNMP_LIB	Makefile	/^LIB_SNMP_LIB = \/usr\/local\/snmp\/lib\/$/;"	m
LIB_XML_INCLUDE	Makefile	/^LIB_XML_INCLUDE = \/usr\/include\/libxml2\/$/;"	m
LINK	Makefile	/^LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \\$/;"	m
LINK_LSA_CT_PER_PAK	lsd_exchange.h	9;"	d
LIPO	Makefile	/^LIPO = $/;"	m
LN_S	Makefile	/^LN_S = ln -s$/;"	m
LOW_PRIORITY_DETECTION	lsd_hello.h	/^	LOW_PRIORITY_DETECTION$/;"	e	enum:priority_type
LSA_CT_PER_PAK	lsd_flood.c	12;"	d	file:
LSDB_LINK_FRESH_TIME	lsd_utils.h	6;"	d
LSD_CHECKSUM	lsd_cmn.h	5;"	d
LSD_CONNECTED	lsd_hello.h	/^	LSD_DISCONNETED = 0, LSD_CONNECTED = 1$/;"	e	enum:lsd_status
LSD_DISCONNETED	lsd_hello.h	/^	LSD_DISCONNETED = 0, LSD_CONNECTED = 1$/;"	e	enum:lsd_status
LSD_HANDLER_H	lsd_handler.h	3;"	d
LSD_UTILS_H	lsd_utils.h	3;"	d
LSD_VERSION	lsd_cmn.h	4;"	d
LTCOMPILE	Makefile	/^LTCOMPILE = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \\$/;"	m
LTLIBOBJS	Makefile	/^LTLIBOBJS = $/;"	m
L_DEAD_VAL	lsd_hello.h	12;"	d
L_HELLO_VAL	lsd_hello.h	10;"	d
MAKEINFO	Makefile	/^MAKEINFO = ${SHELL} \/home\/macro\/workspace\/pma\/missing makeinfo$/;"	m
MANIFEST_TOOL	Makefile	/^MANIFEST_TOOL = :$/;"	m
MAX_EXCHANGE_BUF_LEN	lsd_exchange.h	4;"	d
MAX_FLOOD_BUF_LEN	lsd_flood.h	4;"	d
MAX_MESSAGE_LEN	lsd_hello.h	16;"	d
MAX_MESSAGE_LEN	lsd_socket.h	5;"	d
MAX_RETRY_TIMES	lsd_exchange.h	7;"	d
MKDIR_P	Makefile	/^MKDIR_P = \/usr\/bin\/mkdir -p$/;"	m
N0_DEPENDENCE_ERR	lsd_cmn.h	10;"	d
NM	Makefile	/^NM = \/usr\/bin\/nm -B$/;"	m
NMEDIT	Makefile	/^NMEDIT = $/;"	m
NORMAL_INSTALL	Makefile	/^NORMAL_INSTALL = :$/;"	m
NORMAL_UNINSTALL	Makefile	/^NORMAL_UNINSTALL = :$/;"	m
NOT_FOUND_ERR	lsd_cmn.h	8;"	d
NO_ERR	lsd_cmn.h	6;"	d
NO_MEM_ERR	lsd_cmn.h	7;"	d
OBJDUMP	Makefile	/^OBJDUMP = objdump$/;"	m
OBJEXT	Makefile	/^OBJEXT = o$/;"	m
OTOOL	Makefile	/^OTOOL = $/;"	m
OTOOL64	Makefile	/^OTOOL64 = $/;"	m
PACKAGE	Makefile	/^PACKAGE = pma$/;"	m
PACKAGE_BUGREPORT	Makefile	/^PACKAGE_BUGREPORT = catchgreen@163.com$/;"	m
PACKAGE_NAME	Makefile	/^PACKAGE_NAME = pma$/;"	m
PACKAGE_STRING	Makefile	/^PACKAGE_STRING = pma 2.1$/;"	m
PACKAGE_TARNAME	Makefile	/^PACKAGE_TARNAME = pma$/;"	m
PACKAGE_URL	Makefile	/^PACKAGE_URL = $/;"	m
PACKAGE_VERSION	Makefile	/^PACKAGE_VERSION = 2.1$/;"	m
PATH_SEPARATOR	Makefile	/^PATH_SEPARATOR = :$/;"	m
POST_INSTALL	Makefile	/^POST_INSTALL = :$/;"	m
POST_UNINSTALL	Makefile	/^POST_UNINSTALL = :$/;"	m
PRE_INSTALL	Makefile	/^PRE_INSTALL = :$/;"	m
PRE_UNINSTALL	Makefile	/^PRE_UNINSTALL = :$/;"	m
RANLIB	Makefile	/^RANLIB = ranlib$/;"	m
RCV_OVER_TIME	lsd_exchange.h	6;"	d
SED	Makefile	/^SED = \/usr\/bin\/sed$/;"	m
SERIOUS_ERR	lsd_cmn.h	17;"	d
SET_MAKE	Makefile	/^SET_MAKE = $/;"	m
SHELL	Makefile	/^SHELL = \/bin\/sh$/;"	m
SOURCES	Makefile	/^SOURCES = $(libpmalsd_a_SOURCES)$/;"	m
STRIP	Makefile	/^STRIP = strip$/;"	m
TMP_VAR	lsd_hello.h	14;"	d
VERSION	Makefile	/^VERSION = 2.1$/;"	m
WR_FROMAT_ERR	lsd_cmn.h	11;"	d
__LSDSRV_H__	lsdsrv.h	2;"	d
__LSD_CMN_H__	lsd_cmn.h	2;"	d
__LSD_EVENT_H__	lsd_event.h	2;"	d
__LSD_EXCHANGE_H__	lsd_exchange.h	2;"	d
__LSD_FLOOD_H__	lsd_flood.h	2;"	d
__LSD_HELLO_H__	lsd_hello.h	2;"	d
__LSD_IF_H__	lsd_if.h	2;"	d
__LSD_SOCKET_H__	lsd_socket.h	2;"	d
_ifid	lsd_if.h	29;"	d
_ifid	lsd_if.h	45;"	d
_state	lsd_if.h	30;"	d
_state	lsd_if.h	46;"	d
_type	lsd_if.h	31;"	d
_type	lsd_if.h	47;"	d
abs_builddir	Makefile	/^abs_builddir = \/home\/macro\/workspace\/pma\/lsd$/;"	m
abs_srcdir	Makefile	/^abs_srcdir = \/home\/macro\/workspace\/pma\/lsd$/;"	m
abs_top_builddir	Makefile	/^abs_top_builddir = \/home\/macro\/workspace\/pma$/;"	m
abs_top_srcdir	Makefile	/^abs_top_srcdir = \/home\/macro\/workspace\/pma$/;"	m
ac_ct_AR	Makefile	/^ac_ct_AR = ar$/;"	m
ac_ct_CC	Makefile	/^ac_ct_CC = gcc$/;"	m
ac_ct_DUMPBIN	Makefile	/^ac_ct_DUMPBIN = $/;"	m
accept_lsa_into_lsdb	lsd_utils.c	/^void accept_lsa_into_lsdb(struct backbone_eth* bb_link, struct link_state_adv *ic_lsa)$/;"	f	signature:(struct backbone_eth* bb_link, struct link_state_adv *ic_lsa)
access_eth	lsd_if.h	/^struct access_eth$/;"	s
access_eth::eth_info	lsd_if.h	/^    struct common_eth eth_info;$/;"	m	struct:access_eth	typeref:struct:access_eth::common_eth	access:public
access_eth::interface	lsd_if.h	/^    struct rinterface* interface;$/;"	m	struct:access_eth	typeref:struct:access_eth::rinterface	access:public
access_eth::next	lsd_if.h	/^    struct access_eth* next;$/;"	m	struct:access_eth	typeref:struct:access_eth::access_eth	access:public
access_eth_add	lsd_if.c	/^void access_eth_add(struct access_eth *access_eth)$/;"	f	signature:(struct access_eth *access_eth)
access_eth_add	lsd_if.h	/^void access_eth_add(struct access_eth *access_eth);$/;"	p	signature:(struct access_eth *access_eth)
access_eth_state_handler	lsd_event.h	/^typedef void (*access_eth_state_handler)(struct access_eth* eth);$/;"	t
access_interface_up_handler	lsd_handler.c	/^int access_interface_up_handler(struct access_eth * eth)$/;"	f	signature:(struct access_eth * eth)
access_queue	lsd_event.c	/^define_event_queue(access_queue);$/;"	v
access_queue	lsd_if.c	/^declare_event_queue(access_queue);$/;"	v
accesses	lsd_if.h	/^     struct access_eth* accesses;$/;"	m	struct:lsd_router	typeref:struct:lsd_router::access_eth	access:public
ace_up_handler	lsd_handler.h	/^void ace_up_handler(struct access_eth* eth);$/;"	p	signature:(struct access_eth* eth)
ack_ctrl	lsd_exchange.h	/^	struct thread* ack_ctrl;$/;"	m	struct:exchange_master	typeref:struct:exchange_master::thread	access:public
ack_ctrl	lsd_flood.h	/^	struct thread* ack_ctrl;$/;"	m	struct:flood_master	typeref:struct:flood_master::thread	access:public
ack_time_excceed	lsd_exchange.c	/^int ack_time_excceed (struct thread *thread)$/;"	f	signature:(struct thread *thread)
ack_time_excceed	lsd_exchange.c	/^int ack_time_excceed (struct thread *thread);$/;"	p	file:	signature:(struct thread *thread)
ack_time_excceed	lsd_exchange.h	/^int ack_time_excceed (struct thread *thread);$/;"	p	signature:(struct thread *thread)
add_access_eth_state_handler	lsd_event.c	/^void add_access_eth_state_handler(access_eth_state_handler h)$/;"	f	signature:(access_eth_state_handler h)
add_access_eth_state_handler	lsd_event.h	/^void add_access_eth_state_handler(access_eth_state_handler h);$/;"	p	signature:(access_eth_state_handler h)
add_backbone_eth_state_handler	lsd_event.c	/^void add_backbone_eth_state_handler(backbone_eth_state_handler h)$/;"	f	signature:(backbone_eth_state_handler h)
add_backbone_eth_state_handler	lsd_event.h	/^void add_backbone_eth_state_handler(backbone_eth_state_handler h);$/;"	p	signature:(backbone_eth_state_handler h)
add_exchange_handler	lsd_event.c	/^void add_exchange_handler(exchange_handler h)$/;"	f	signature:(exchange_handler h)
add_exchange_handler	lsd_event.h	/^void add_exchange_handler(exchange_handler h);$/;"	p	signature:(exchange_handler h)
add_hello_detection_handler	lsd_event.c	/^void add_hello_detection_handler(hello_detection_handler handler)$/;"	f	signature:(hello_detection_handler handler)
add_hello_detection_handler	lsd_event.h	/^void add_hello_detection_handler(hello_detection_handler handler);$/;"	p	signature:(hello_detection_handler handler)
add_pkt_rcv_handler	lsd_event.c	/^void add_pkt_rcv_handler(pkt_rcv_handler h)$/;"	f	signature:(pkt_rcv_handler h)
add_pkt_rcv_handler	lsd_event.h	/^void add_pkt_rcv_handler(pkt_rcv_handler h);$/;"	p	signature:(pkt_rcv_handler h)
adjust_time	lsd_if.h	/^    struct timeval adjust_time; \/\/$/;"	m	struct:backbone_eth	typeref:struct:backbone_eth::timeval	access:public
am__aclocal_m4_deps	Makefile	/^am__aclocal_m4_deps = $(top_srcdir)\/configure.ac$/;"	m
am__can_run_installinfo	Makefile	/^am__can_run_installinfo = \\$/;"	m
am__cd	Makefile	/^am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd$/;"	m
am__configure_deps	Makefile	/^am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \\$/;"	m
am__define_uniq_tagged_files	Makefile	/^am__define_uniq_tagged_files = \\$/;"	m
am__depfiles_maybe	Makefile	/^am__depfiles_maybe = depfiles$/;"	m
am__include	Makefile	/^am__include = include$/;"	m
am__is_gnu_make	Makefile	/^am__is_gnu_make = test -n '$(MAKEFILE_LIST)' && test -n '$(MAKELEVEL)'$/;"	m
am__leading_dot	Makefile	/^am__leading_dot = .$/;"	m
am__make_dryrun	Makefile	/^am__make_dryrun = (target_option=n; $(am__make_running_with_option))$/;"	m
am__make_keepgoing	Makefile	/^am__make_keepgoing = (target_option=k; $(am__make_running_with_option))$/;"	m
am__make_running_with_option	Makefile	/^am__make_running_with_option = \\$/;"	m
am__mv	Makefile	/^am__mv = mv -f$/;"	m
am__quote	Makefile	/^am__quote = $/;"	m
am__tagged_files	Makefile	/^am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP)$/;"	m
am__tar	Makefile	/^am__tar = $${TAR-tar} chof - "$$tardir"$/;"	m
am__uniquify_input	Makefile	/^am__uniquify_input = $(AWK) '\\$/;"	m
am__untar	Makefile	/^am__untar = $${TAR-tar} xf -$/;"	m
am__v_AR_	Makefile	/^am__v_AR_ = $(am__v_AR_$(AM_DEFAULT_VERBOSITY))$/;"	m
am__v_AR_0	Makefile	/^am__v_AR_0 = @echo "  AR      " $@;$/;"	m
am__v_AR_1	Makefile	/^am__v_AR_1 = $/;"	m
am__v_CCLD_	Makefile	/^am__v_CCLD_ = $(am__v_CCLD_$(AM_DEFAULT_VERBOSITY))$/;"	m
am__v_CCLD_0	Makefile	/^am__v_CCLD_0 = @echo "  CCLD    " $@;$/;"	m
am__v_CCLD_1	Makefile	/^am__v_CCLD_1 = $/;"	m
am__v_CC_	Makefile	/^am__v_CC_ = $(am__v_CC_$(AM_DEFAULT_VERBOSITY))$/;"	m
am__v_CC_0	Makefile	/^am__v_CC_0 = @echo "  CC      " $@;$/;"	m
am__v_CC_1	Makefile	/^am__v_CC_1 = $/;"	m
am__v_GEN_	Makefile	/^am__v_GEN_ = $(am__v_GEN_$(AM_DEFAULT_VERBOSITY))$/;"	m
am__v_GEN_0	Makefile	/^am__v_GEN_0 = @echo "  GEN     " $@;$/;"	m
am__v_GEN_1	Makefile	/^am__v_GEN_1 = $/;"	m
am__v_P_	Makefile	/^am__v_P_ = $(am__v_P_$(AM_DEFAULT_VERBOSITY))$/;"	m
am__v_P_0	Makefile	/^am__v_P_0 = false$/;"	m
am__v_P_1	Makefile	/^am__v_P_1 = :$/;"	m
am__v_at_	Makefile	/^am__v_at_ = $(am__v_at_$(AM_DEFAULT_VERBOSITY))$/;"	m
am__v_at_0	Makefile	/^am__v_at_0 = @$/;"	m
am__v_at_1	Makefile	/^am__v_at_1 = $/;"	m
am__v_lt_	Makefile	/^am__v_lt_ = $(am__v_lt_$(AM_DEFAULT_VERBOSITY))$/;"	m
am__v_lt_0	Makefile	/^am__v_lt_0 = --silent$/;"	m
am__v_lt_1	Makefile	/^am__v_lt_1 = $/;"	m
am_libpmalsd_a_OBJECTS	Makefile	/^am_libpmalsd_a_OBJECTS = lsdsrv.$(OBJEXT) lsd_hello.$(OBJEXT) \\$/;"	m
area_id	lsd_socket.h	/^	u32 area_id;$/;"	m	struct:lsd_head	access:public
autonomous_zone	lsd_if.h	/^struct autonomous_zone \/\/area in ospf $/;"	s
autonomous_zone::az_id	lsd_if.h	/^     u32 az_id;  \/\/area id$/;"	m	struct:autonomous_zone	access:public
autonomous_zone::backbones	lsd_if.h	/^     struct backbone_eth* backbones;\/\/backbone interfaces$/;"	m	struct:autonomous_zone	typeref:struct:autonomous_zone::backbone_eth	access:public
autonomous_zone::lidb	lsd_if.h	/^     id_t lidb; \/\/lidb of the area \/\/2013.04.09  not used in ic$/;"	m	struct:autonomous_zone	access:public
autonomous_zone::lsdb	lsd_if.h	/^     id_t lsdb; \/\/ lsdb of the area$/;"	m	struct:autonomous_zone	access:public
autonomous_zone::next	lsd_if.h	/^     struct autonomous_zone* next; $/;"	m	struct:autonomous_zone	typeref:struct:autonomous_zone::autonomous_zone	access:public
autonomous_zone::r_id	lsd_if.h	/^     u32 r_id;  \/\/routerid exposed to the area$/;"	m	struct:autonomous_zone	access:public
autonomous_zone_add	lsd_if.c	/^void autonomous_zone_add(struct autonomous_zone *az)$/;"	f	signature:(struct autonomous_zone *az)
autonomous_zone_add	lsd_if.h	/^void autonomous_zone_add(struct autonomous_zone *az);$/;"	p	signature:(struct autonomous_zone *az)
az	lsd_if.h	/^    struct autonomous_zone* az; \/\/whic area this if belongs to$/;"	m	struct:backbone_eth	typeref:struct:backbone_eth::autonomous_zone	access:public
az_id	lsd_if.h	/^     u32 az_id;  \/\/area id$/;"	m	struct:autonomous_zone	access:public
azs	lsd_if.h	/^     struct autonomous_zone* azs; \/\/$/;"	m	struct:lsd_router	typeref:struct:lsd_router::autonomous_zone	access:public
backbone_eth	lsd_if.h	/^struct backbone_eth  \/\/BackBone Interface$/;"	s
backbone_eth::adjust_time	lsd_if.h	/^    struct timeval adjust_time; \/\/$/;"	m	struct:backbone_eth	typeref:struct:backbone_eth::timeval	access:public
backbone_eth::az	lsd_if.h	/^    struct autonomous_zone* az; \/\/whic area this if belongs to$/;"	m	struct:backbone_eth	typeref:struct:backbone_eth::autonomous_zone	access:public
backbone_eth::eth_info	lsd_if.h	/^    struct common_eth eth_info;$/;"	m	struct:backbone_eth	typeref:struct:backbone_eth::common_eth	access:public
backbone_eth::exchange_master	lsd_if.h	/^    void* exchange_master; \/\/ctrl of the exchange protrocl$/;"	m	struct:backbone_eth	access:public
backbone_eth::flood_master	lsd_if.h	/^    void* flood_master; \/\/ctrl of the flood protocl$/;"	m	struct:backbone_eth	access:public
backbone_eth::hello_master	lsd_if.h	/^    void* hello_master; \/\/ctrl of the hello protocl$/;"	m	struct:backbone_eth	access:public
backbone_eth::interface	lsd_if.h	/^    struct rinterface * interface; \/\/the detail infomation of the interface$/;"	m	struct:backbone_eth	typeref:struct:backbone_eth::rinterface	access:public
backbone_eth::neighbor_pma	lsd_if.h	/^    struct neighbor_pma neighbor_pma; $/;"	m	struct:backbone_eth	typeref:struct:backbone_eth::neighbor_pma	access:public
backbone_eth::next	lsd_if.h	/^    struct backbone_eth* next; \/\/next interface$/;"	m	struct:backbone_eth	typeref:struct:backbone_eth::backbone_eth	access:public
backbone_eth_add	lsd_if.c	/^void backbone_eth_add(struct autonomous_zone* azone,struct backbone_eth *backbone_eth)$/;"	f	signature:(struct autonomous_zone* azone,struct backbone_eth *backbone_eth)
backbone_eth_add	lsd_if.h	/^void backbone_eth_add(struct autonomous_zone* azone,struct backbone_eth *backbone_eth);$/;"	p	signature:(struct autonomous_zone* azone,struct backbone_eth *backbone_eth)
backbone_eth_state_handler	lsd_event.h	/^typedef void (*backbone_eth_state_handler)(struct backbone_eth* eth);$/;"	t
backbone_queue	lsd_event.c	/^define_event_queue(backbone_queue);$/;"	v
backbone_queue	lsd_if.c	/^declare_event_queue(backbone_queue);$/;"	v
backbones	lsd_if.h	/^     struct backbone_eth* backbones;\/\/backbone interfaces$/;"	m	struct:autonomous_zone	typeref:struct:autonomous_zone::backbone_eth	access:public
bbe_up_handler	lsd_handler.h	/^void bbe_up_handler(struct backbone_eth* eth);$/;"	p	signature:(struct backbone_eth* eth)
bindir	Makefile	/^bindir = ${exec_prefix}\/bin$/;"	m
build	Makefile	/^build = i686-pc-linux-gnu$/;"	m
build_alias	Makefile	/^build_alias = $/;"	m
build_cpu	Makefile	/^build_cpu = i686$/;"	m
build_os	Makefile	/^build_os = linux-gnu$/;"	m
build_triplet	Makefile	/^build_triplet = i686-pc-linux-gnu$/;"	m
build_vendor	Makefile	/^build_vendor = pc$/;"	m
builddir	Makefile	/^builddir = .$/;"	m
check_local_lsdb	lsd_utils.c	/^int check_local_lsdb(struct backbone_eth* bb_link, struct cr_lsdb_link_state* state)$/;"	f	signature:(struct backbone_eth* bb_link, struct cr_lsdb_link_state* state)
common_eth	lsd_if.h	/^struct common_eth{$/;"	s
common_eth::ifid	lsd_if.h	/^    u32 ifid;$/;"	m	struct:common_eth	access:public
common_eth::state	lsd_if.h	/^    enum eth_state state;$/;"	m	struct:common_eth	typeref:enum:common_eth::eth_state	access:public
common_eth::type	lsd_if.h	/^    enum eth_type type;$/;"	m	struct:common_eth	typeref:enum:common_eth::eth_type	access:public
create_server	lsd_socket.c	/^int create_server(int listen_port, int type){$/;"	f	signature:(int listen_port, int type)
create_server	lsd_socket.h	/^int create_server(int listen_port, int type);$/;"	p	signature:(int listen_port, int type)
data	lsd_handler.h	/^	u_int8_t data;$/;"	m	union:state_changer	access:public
datadir	Makefile	/^datadir = ${datarootdir}$/;"	m
datarootdir	Makefile	/^datarootdir = ${prefix}\/share$/;"	m
dead_interval	lsd_hello.h	/^	u32 dead_interval;$/;"	m	struct:hello_high	access:public
dead_interval	lsd_hello.h	/^	u32 dead_interval;$/;"	m	struct:hello_low	access:public
dead_timer_high	lsd_hello.c	/^int dead_timer_high(struct thread *thread)$/;"	f	signature:(struct thread *thread)
dead_timer_high	lsd_hello.h	/^	struct thread* dead_timer_high;$/;"	m	struct:hello_master	typeref:struct:hello_master::thread	access:public
dead_timer_high	lsd_hello.h	/^int dead_timer_high(struct thread *thread);$/;"	p	signature:(struct thread *thread)
dead_timer_low	lsd_hello.c	/^int dead_timer_low(struct thread *thread)$/;"	f	signature:(struct thread *thread)
dead_timer_low	lsd_hello.h	/^	struct thread* dead_timer_low;$/;"	m	struct:hello_master	typeref:struct:hello_master::thread	access:public
dead_timer_low	lsd_hello.h	/^int dead_timer_low(struct thread *thread);$/;"	p	signature:(struct thread *thread)
depcomp	Makefile	/^depcomp = $(SHELL) $(top_srcdir)\/depcomp$/;"	m
detection_queue	lsd_event.c	/^define_event_queue(detection_queue);$/;"	v
detection_queue	lsd_hello.c	/^declare_event_queue(detection_queue);$/;"	v
docdir	Makefile	/^docdir = ${datarootdir}\/doc\/${PACKAGE_TARNAME}$/;"	m
dvidir	Makefile	/^dvidir = ${docdir}$/;"	m
eth_info	lsd_if.h	/^    struct common_eth eth_info;$/;"	m	struct:access_eth	typeref:struct:access_eth::common_eth	access:public
eth_info	lsd_if.h	/^    struct common_eth eth_info;$/;"	m	struct:backbone_eth	typeref:struct:backbone_eth::common_eth	access:public
eth_state	lsd_if.h	/^enum eth_state{$/;"	g
eth_state_update	lsd_if.c	/^int eth_state_update(struct common_eth* eth)$/;"	f	signature:(struct common_eth* eth)
eth_state_update	lsd_if.h	/^int eth_state_update(struct common_eth* eth); \/\/update the state of if$/;"	p	signature:(struct common_eth* eth)
eth_type	lsd_if.h	/^enum eth_type{$/;"	g
ex_ack_received	lsd_exchange.c	/^void ex_ack_received(struct backbone_eth* eth,struct exchange *ex_header)$/;"	f	signature:(struct backbone_eth* eth,struct exchange *ex_header)
ex_ack_received	lsd_exchange.c	/^void ex_ack_received(struct backbone_eth* eth,struct exchange *ex_header);$/;"	p	file:	signature:(struct backbone_eth* eth,struct exchange *ex_header)
exchange	lsd_exchange.h	/^struct exchange$/;"	s
exchange::length	lsd_exchange.h	/^	u16 length;$/;"	m	struct:exchange	access:public
exchange::lsd_hd	lsd_exchange.h	/^	struct lsd_head lsd_hd;$/;"	m	struct:exchange	typeref:struct:exchange::lsd_head	access:public
exchange::more	lsd_exchange.h	/^	u8 more;$/;"	m	struct:exchange	access:public
exchange::seq	lsd_exchange.h	/^	u32 seq;$/;"	m	struct:exchange	access:public
exchange::type	lsd_exchange.h	/^	u8 type;$/;"	m	struct:exchange	access:public
exchange_handler	lsd_event.h	/^typedef void (*exchange_handler)(struct backbone_eth* eth);$/;"	t
exchange_master	lsd_exchange.h	/^struct exchange_master$/;"	s
exchange_master	lsd_if.h	/^    void* exchange_master; \/\/ctrl of the exchange protrocl$/;"	m	struct:backbone_eth	access:public
exchange_master::ack_ctrl	lsd_exchange.h	/^	struct thread* ack_ctrl;$/;"	m	struct:exchange_master	typeref:struct:exchange_master::thread	access:public
exchange_master::has_more	lsd_exchange.h	/^	u8 has_more;$/;"	m	struct:exchange_master	access:public
exchange_master::interface	lsd_exchange.h	/^	struct backbone_eth* interface;$/;"	m	struct:exchange_master	typeref:struct:exchange_master::backbone_eth	access:public
exchange_master::links_state	lsd_exchange.h	/^	struct cr_lsdb_link_state* links_state;$/;"	m	struct:exchange_master	typeref:struct:exchange_master::cr_lsdb_link_state	access:public
exchange_master::pkg_no	lsd_exchange.h	/^	u32 pkg_no;$/;"	m	struct:exchange_master	access:public
exchange_master::rcv_ctrl	lsd_exchange.h	/^	struct thread* rcv_ctrl;$/;"	m	struct:exchange_master	typeref:struct:exchange_master::thread	access:public
exchange_master::rcv_state	lsd_exchange.h	/^	enum exchange_rcv_state rcv_state;$/;"	m	struct:exchange_master	typeref:enum:exchange_master::exchange_rcv_state	access:public
exchange_master::retry_times	lsd_exchange.h	/^	int retry_times;$/;"	m	struct:exchange_master	access:public
exchange_master::send_state	lsd_exchange.h	/^	enum exchange_send_state send_state;$/;"	m	struct:exchange_master	typeref:enum:exchange_master::exchange_send_state	access:public
exchange_master::sendbuf	lsd_exchange.h	/^	char sendbuf[MAX_EXCHANGE_BUF_LEN];$/;"	m	struct:exchange_master	access:public
exchange_on_eth_state_changed	lsd_exchange.c	/^void exchange_on_eth_state_changed(struct backbone_eth* eth)$/;"	f	signature:(struct backbone_eth* eth)
exchange_on_eth_state_changed	lsd_exchange.h	/^void exchange_on_eth_state_changed(struct backbone_eth* eth);$/;"	p	signature:(struct backbone_eth* eth)
exchange_pkt_received	lsd_exchange.c	/^void exchange_pkt_received(struct backbone_eth* eth, struct lsd_head *head)$/;"	f	signature:(struct backbone_eth* eth, struct lsd_head *head)
exchange_pkt_received	lsd_exchange.c	/^void exchange_pkt_received(struct backbone_eth* eth, struct lsd_head *head);$/;"	p	file:	signature:(struct backbone_eth* eth, struct lsd_head *head)
exchange_pkt_received	lsd_exchange.h	/^void exchange_pkt_received(struct backbone_eth* eth, struct lsd_head *head);$/;"	p	signature:(struct backbone_eth* eth, struct lsd_head *head)
exchange_queue	lsd_event.c	/^define_event_queue(exchange_queue);$/;"	v
exchange_queue	lsd_exchange.c	/^declare_event_queue(exchange_queue);$/;"	v
exchange_rcv_state	lsd_exchange.h	/^enum exchange_rcv_state{$/;"	g
exchange_send	lsd_exchange.c	/^static int exchange_send (struct backbone_eth* eth)$/;"	f	file:	signature:(struct backbone_eth* eth)
exchange_send	lsd_exchange.c	/^static int exchange_send (struct backbone_eth* eth);$/;"	p	file:	signature:(struct backbone_eth* eth)
exchange_send_ack	lsd_exchange.c	/^static void exchange_send_ack(struct backbone_eth* eth,struct exchange *ex_header)$/;"	f	file:	signature:(struct backbone_eth* eth,struct exchange *ex_header)
exchange_send_ack	lsd_exchange.c	/^static void exchange_send_ack(struct backbone_eth* eth,struct exchange *ex_header);$/;"	p	file:	signature:(struct backbone_eth* eth,struct exchange *ex_header)
exchange_send_start	lsd_exchange.c	/^int exchange_send_start(struct backbone_eth* eth)$/;"	f	signature:(struct backbone_eth* eth)
exchange_send_start	lsd_exchange.c	/^int exchange_send_start(struct backbone_eth* eth);$/;"	p	file:	signature:(struct backbone_eth* eth)
exchange_send_start	lsd_exchange.h	/^int exchange_send_start(struct backbone_eth* eth);$/;"	p	signature:(struct backbone_eth* eth)
exchange_send_state	lsd_exchange.h	/^enum exchange_send_state{$/;"	g
exchange_terminate	lsd_exchange.c	/^void exchange_terminate(struct backbone_eth* eth)$/;"	f	signature:(struct backbone_eth* eth)
exchange_terminate	lsd_exchange.c	/^void exchange_terminate(struct backbone_eth* eth);$/;"	p	file:	signature:(struct backbone_eth* eth)
exchange_terminate	lsd_exchange.h	/^void exchange_terminate(struct backbone_eth* eth);$/;"	p	signature:(struct backbone_eth* eth)
exec_prefix	Makefile	/^exec_prefix = ${prefix}$/;"	m
field	lsd_handler.h	/^	}field;$/;"	m	union:state_changer	typeref:struct:state_changer::__anon1	access:public
find_autonomous_zone	lsd_if.c	/^struct autonomous_zone* find_autonomous_zone(int area_id){$/;"	f	signature:(int area_id)
find_autonomous_zone	lsd_if.h	/^struct autonomous_zone* find_autonomous_zone(int area_id);$/;"	p	signature:(int area_id)
finish_rcv	lsd_exchange.h	/^void finish_rcv(enum exchange_rcv_state state, struct exchange_master *ex_master);$/;"	p	signature:(enum exchange_rcv_state state, struct exchange_master *ex_master)
finish_send	lsd_exchange.h	/^void finish_send(enum exchange_send_state state, struct exchange_master *ex_master);$/;"	p	signature:(enum exchange_send_state state, struct exchange_master *ex_master)
flood	lsd_flood.h	/^struct flood$/;"	s
flood::lsd_hd	lsd_flood.h	/^	struct lsd_head lsd_hd;$/;"	m	struct:flood	typeref:struct:flood::lsd_head	access:public
flood::seq	lsd_flood.h	/^	u32 seq;$/;"	m	struct:flood	access:public
flood::size	lsd_flood.h	/^	u32 size;$/;"	m	struct:flood	access:public
flood::type	lsd_flood.h	/^	u8 type;$/;"	m	struct:flood	access:public
flood_ack_timeout	lsd_flood.c	/^int flood_ack_timeout(struct thread *thread)$/;"	f	signature:(struct thread *thread)
flood_add_flood_lsa	lsd_flood.c	/^void flood_add_flood_lsa(struct link_state_adv* lsa, struct backbone_eth* eth)$/;"	f	signature:(struct link_state_adv* lsa, struct backbone_eth* eth)
flood_add_flood_lsa	lsd_flood.h	/^void flood_add_flood_lsa(struct link_state_adv* lsa, struct backbone_eth* eth);$/;"	p	signature:(struct link_state_adv* lsa, struct backbone_eth* eth)
flood_lsa_forward	lsd_flood.c	/^void flood_lsa_forward(struct link_state_adv* lsa, struct backbone_eth* eth)$/;"	f	signature:(struct link_state_adv* lsa, struct backbone_eth* eth)
flood_lsa_forward	lsd_flood.h	/^void flood_lsa_forward(struct link_state_adv* lsa, struct backbone_eth* eth);$/;"	p	signature:(struct link_state_adv* lsa, struct backbone_eth* eth)
flood_lsa_spread	lsd_flood.c	/^void flood_lsa_spread(struct link_state_adv* lsa, struct autonomous_zone* oz)$/;"	f	signature:(struct link_state_adv* lsa, struct autonomous_zone* oz)
flood_master	lsd_flood.h	/^struct flood_master$/;"	s
flood_master	lsd_if.h	/^    void* flood_master; \/\/ctrl of the flood protocl$/;"	m	struct:backbone_eth	access:public
flood_master::ack_ctrl	lsd_flood.h	/^	struct thread* ack_ctrl;$/;"	m	struct:flood_master	typeref:struct:flood_master::thread	access:public
flood_master::interface	lsd_flood.h	/^	struct backbone_eth* interface;$/;"	m	struct:flood_master	typeref:struct:flood_master::backbone_eth	access:public
flood_master::pkg_no	lsd_flood.h	/^	u32 pkg_no;$/;"	m	struct:flood_master	access:public
flood_master::queue	lsd_flood.h	/^	struct cr_list_head queue;$/;"	m	struct:flood_master	typeref:struct:flood_master::cr_list_head	access:public
flood_master::sendbuf	lsd_flood.h	/^	char sendbuf[MAX_FLOOD_BUF_LEN];$/;"	m	struct:flood_master	access:public
flood_master::snd_ctrl	lsd_flood.h	/^	struct thread* snd_ctrl;$/;"	m	struct:flood_master	typeref:struct:flood_master::thread	access:public
flood_master::state	lsd_flood.h	/^	enum flood_state state;$/;"	m	struct:flood_master	typeref:enum:flood_master::flood_state	access:public
flood_on_eth_state_changed	lsd_flood.c	/^void flood_on_eth_state_changed(struct backbone_eth* eth)$/;"	f	signature:(struct backbone_eth* eth)
flood_on_eth_state_changed	lsd_flood.h	/^void flood_on_eth_state_changed(struct backbone_eth* eth);$/;"	p	signature:(struct backbone_eth* eth)
flood_periodically_flood_start	lsd_flood.c	/^void flood_periodically_flood_start()$/;"	f
flood_periodically_flood_terminate	lsd_flood.c	/^void flood_periodically_flood_terminate()$/;"	f
flood_pkt_received	lsd_flood.c	/^void flood_pkt_received(struct backbone_eth* eth, struct lsd_head *head)$/;"	f	signature:(struct backbone_eth* eth, struct lsd_head *head)
flood_pkt_received	lsd_flood.h	/^void flood_pkt_received(struct backbone_eth* eth, struct lsd_head *head);$/;"	p	signature:(struct backbone_eth* eth, struct lsd_head *head)
flood_send_ack	lsd_flood.c	/^static void flood_send_ack(struct backbone_eth* link, struct flood* header)$/;"	f	file:	signature:(struct backbone_eth* link, struct flood* header)
flood_send_lsa	lsd_flood.c	/^int flood_send_lsa(struct thread *thread)$/;"	f	signature:(struct thread *thread)
flood_snd_item	lsd_flood.h	/^struct flood_snd_item$/;"	s
flood_snd_item::lsa	lsd_flood.h	/^	struct link_state_adv lsa;$/;"	m	struct:flood_snd_item	typeref:struct:flood_snd_item::link_state_adv	access:public
flood_snd_item::ptrs	lsd_flood.h	/^	struct cr_list_head ptrs;$/;"	m	struct:flood_snd_item	typeref:struct:flood_snd_item::cr_list_head	access:public
flood_spread_access_link_state	lsd_flood.c	/^void flood_spread_access_link_state(struct access_eth* eth, u8 state)$/;"	f	signature:(struct access_eth* eth, u8 state)
flood_spread_backbone_link_state	lsd_flood.c	/^void flood_spread_backbone_link_state(struct backbone_eth* eth, u8 state)$/;"	f	signature:(struct backbone_eth* eth, u8 state)
flood_start	lsd_flood.c	/^void flood_start(struct backbone_eth* eth)$/;"	f	signature:(struct backbone_eth* eth)
flood_state	lsd_flood.h	/^enum flood_state{$/;"	g
flood_terminate	lsd_flood.c	/^void flood_terminate(struct backbone_eth* eth)$/;"	f	signature:(struct backbone_eth* eth)
g_lsd_router	lsd_if.c	/^struct lsd_router g_lsd_router;$/;"	v	typeref:struct:lsd_router
get_address_of_backbone	lsd_if.c	/^int  get_address_of_backbone( struct backbone_eth* eth, struct in_addr* addr)$/;"	f	signature:( struct backbone_eth* eth, struct in_addr* addr)
get_area_id_by_lsdb_handle	lsd_if.c	/^u32 get_area_id_by_lsdb_handle(id_t lsdb_handle)$/;"	f	signature:(id_t lsdb_handle)
get_area_id_by_lsdb_handle	lsd_if.h	/^u32 get_area_id_by_lsdb_handle(id_t lsdb_handle);$/;"	p	signature:(id_t lsdb_handle)
get_autonomous_zone_by_id	lsd_if.c	/^struct autonomous_zone* get_autonomous_zone_by_id(u32 area_id)$/;"	f	signature:(u32 area_id)
get_backbone_by_neighbor_id	lsd_if.c	/^struct backbone_eth* get_backbone_by_neighbor_id(struct autonomous_zone* az, int id){$/;"	f	signature:(struct autonomous_zone* az, int id)
get_backbone_eth_area	lsd_if.h	89;"	d
get_metric_of_backbone	lsd_if.c	/^int get_metric_of_backbone( struct backbone_eth * eth)$/;"	f	signature:( struct backbone_eth * eth)
h_dead_val	lsd_hello.h	/^	u32 h_dead_val;$/;"	m	struct:hello_master	access:public
h_hello_val	lsd_hello.h	/^	u32 h_hello_val;$/;"	m	struct:hello_master	access:public
has_more	lsd_exchange.h	/^	u8 has_more;$/;"	m	struct:exchange_master	access:public
hello_changed_handler	lsd_handler.c	/^void hello_changed_handler(struct backbone_eth* eth,$/;"	f	signature:(struct backbone_eth* eth, enum priority_type type, enum lsd_status status)
hello_changed_handler	lsd_handler.h	/^void hello_changed_handler(struct backbone_eth* eth,$/;"	p	signature:(struct backbone_eth* eth, enum priority_type type, enum lsd_status status)
hello_detection_handler	lsd_event.h	/^typedef void (*hello_detection_handler)(struct backbone_eth* eth,enum priority_type type, enum lsd_status status);$/;"	t
hello_exchange_handler	lsd_handler.h	/^void hello_exchange_handler(struct backbone_eth* eth,$/;"	p	signature:(struct backbone_eth* eth, enum priority_type type, enum lsd_status status)
hello_get_eth_state	lsd_hello.c	/^void hello_get_eth_state(struct backbone_eth* eth,$/;"	f	signature:(struct backbone_eth* eth, enum eth_state * high, enum eth_state * low)
hello_get_eth_state	lsd_hello.h	/^void hello_get_eth_state(struct backbone_eth* eth,$/;"	p	signature:(struct backbone_eth* eth, enum eth_state* high, enum eth_state* low)
hello_get_neighbor_info	lsd_hello.c	/^void hello_get_neighbor_info(struct backbone_eth* eth,$/;"	f	signature:(struct backbone_eth* eth, struct lsd_neighbor_info* neighbor)
hello_get_neighbor_info	lsd_hello.h	/^void hello_get_neighbor_info(struct backbone_eth* eth,$/;"	p	signature:(struct backbone_eth* eth, struct lsd_neighbor_info* neighbor)
hello_high	lsd_handler.h	/^		u_int8_t hello_high : 1;$/;"	m	struct:state_changer::__anon1	access:public
hello_high	lsd_hello.h	/^struct hello_high$/;"	s
hello_high::dead_interval	lsd_hello.h	/^	u32 dead_interval;$/;"	m	struct:hello_high	access:public
hello_high::hello_interval	lsd_hello.h	/^	u32 hello_interval;$/;"	m	struct:hello_high	access:public
hello_high::lsd_head	lsd_hello.h	/^	struct lsd_head lsd_head;$/;"	m	struct:hello_high	typeref:struct:hello_high::lsd_head	access:public
hello_high_send	lsd_hello.c	/^int hello_high_send(struct thread *thread)$/;"	f	signature:(struct thread *thread)
hello_high_send	lsd_hello.h	/^int hello_high_send(struct thread *thread);$/;"	p	signature:(struct thread *thread)
hello_interval	lsd_hello.h	/^	u32 hello_interval;$/;"	m	struct:hello_high	access:public
hello_interval	lsd_hello.h	/^	u32 hello_interval;$/;"	m	struct:hello_low	access:public
hello_low	lsd_handler.h	/^		u_int8_t hello_low : 1;$/;"	m	struct:state_changer::__anon1	access:public
hello_low	lsd_hello.h	/^struct hello_low$/;"	s
hello_low::dead_interval	lsd_hello.h	/^	u32 dead_interval;$/;"	m	struct:hello_low	access:public
hello_low::hello_interval	lsd_hello.h	/^	u32 hello_interval;$/;"	m	struct:hello_low	access:public
hello_low::lsd_head	lsd_hello.h	/^	struct lsd_head lsd_head;$/;"	m	struct:hello_low	typeref:struct:hello_low::lsd_head	access:public
hello_low_send	lsd_hello.c	/^int hello_low_send(struct thread * thread)$/;"	f	signature:(struct thread * thread)
hello_low_send	lsd_hello.h	/^int hello_low_send(struct thread *thread);$/;"	p	signature:(struct thread *thread)
hello_master	lsd_hello.h	/^struct hello_master$/;"	s
hello_master	lsd_if.h	/^    void* hello_master; \/\/ctrl of the hello protocl$/;"	m	struct:backbone_eth	access:public
hello_master::dead_timer_high	lsd_hello.h	/^	struct thread* dead_timer_high;$/;"	m	struct:hello_master	typeref:struct:hello_master::thread	access:public
hello_master::dead_timer_low	lsd_hello.h	/^	struct thread* dead_timer_low;$/;"	m	struct:hello_master	typeref:struct:hello_master::thread	access:public
hello_master::h_dead_val	lsd_hello.h	/^	u32 h_dead_val;$/;"	m	struct:hello_master	access:public
hello_master::h_hello_val	lsd_hello.h	/^	u32 h_hello_val;$/;"	m	struct:hello_master	access:public
hello_master::hello_timer_high	lsd_hello.h	/^	struct thread* hello_timer_high;$/;"	m	struct:hello_master	typeref:struct:hello_master::thread	access:public
hello_master::hello_timer_low	lsd_hello.h	/^	struct thread* hello_timer_low;$/;"	m	struct:hello_master	typeref:struct:hello_master::thread	access:public
hello_master::high_status	lsd_hello.h	/^	enum lsd_status high_status;$/;"	m	struct:hello_master	typeref:enum:hello_master::lsd_status	access:public
hello_master::l_dead_val	lsd_hello.h	/^	u32 l_dead_val;$/;"	m	struct:hello_master	access:public
hello_master::l_hello_val	lsd_hello.h	/^	u32 l_hello_val;$/;"	m	struct:hello_master	access:public
hello_master::low_status	lsd_hello.h	/^	enum lsd_status low_status;$/;"	m	struct:hello_master	typeref:enum:hello_master::lsd_status	access:public
hello_master::neighbor	lsd_hello.h	/^	struct lsd_neighbor_info neighbor;$/;"	m	struct:hello_master	typeref:struct:hello_master::lsd_neighbor_info	access:public
hello_on_eth_state_changed	lsd_hello.c	/^void hello_on_eth_state_changed(struct backbone_eth* eth)$/;"	f	signature:(struct backbone_eth* eth)
hello_on_eth_state_changed	lsd_hello.h	/^void hello_on_eth_state_changed(struct backbone_eth* eth);$/;"	p	signature:(struct backbone_eth* eth)
hello_on_high_packet_received	lsd_hello.c	/^void hello_on_high_packet_received(struct backbone_eth* eth, struct lsd_head *head)$/;"	f	signature:(struct backbone_eth* eth, struct lsd_head *head)
hello_on_high_packet_received	lsd_hello.h	/^void hello_on_high_packet_received(struct backbone_eth* eth, struct lsd_head *head);$/;"	p	signature:(struct backbone_eth* eth, struct lsd_head *head)
hello_on_low_packet_received	lsd_hello.c	/^void hello_on_low_packet_received(struct backbone_eth* eth, struct lsd_head *head)$/;"	f	signature:(struct backbone_eth* eth, struct lsd_head *head)
hello_on_low_packet_received	lsd_hello.h	/^void hello_on_low_packet_received(struct backbone_eth* eth, struct lsd_head *head);$/;"	p	signature:(struct backbone_eth* eth, struct lsd_head *head)
hello_timer_high	lsd_hello.h	/^	struct thread* hello_timer_high;$/;"	m	struct:hello_master	typeref:struct:hello_master::thread	access:public
hello_timer_low	lsd_hello.h	/^	struct thread* hello_timer_low;$/;"	m	struct:hello_master	typeref:struct:hello_master::thread	access:public
high_status	lsd_hello.h	/^	enum lsd_status high_status;$/;"	m	struct:hello_master	typeref:enum:hello_master::lsd_status	access:public
host	Makefile	/^host = i686-pc-linux-gnu$/;"	m
host_alias	Makefile	/^host_alias = $/;"	m
host_cpu	Makefile	/^host_cpu = i686$/;"	m
host_os	Makefile	/^host_os = linux-gnu$/;"	m
host_triplet	Makefile	/^host_triplet = i686-pc-linux-gnu$/;"	m
host_vendor	Makefile	/^host_vendor = pc$/;"	m
htmldir	Makefile	/^htmldir = ${docdir}$/;"	m
icsum	lsd_socket.h	/^	u32 icsum;$/;"	m	struct:lsd_head	access:public
id_t	lsd_if.h	/^typedef  unsigned int  id_t;$/;"	t
if_id	lsd_hello.h	/^	u32 if_id;$/;"	m	struct:lsd_neighbor_info	access:public
if_id	lsd_socket.h	/^	u32 if_id;$/;"	m	struct:lsd_head	access:public
ifid	lsd_if.h	/^    u32 ifid;$/;"	m	struct:common_eth	access:public
includedir	Makefile	/^includedir = ${prefix}\/include$/;"	m
info1	lsd_handler.h	/^		u_int8_t info1 : 1;$/;"	m	struct:state_changer::__anon1	access:public
info2	lsd_handler.h	/^		u_int8_t info2 : 1;$/;"	m	struct:state_changer::__anon1	access:public
info3	lsd_handler.h	/^		u_int8_t info3 : 1;$/;"	m	struct:state_changer::__anon1	access:public
info4	lsd_handler.h	/^		u_int8_t info4 : 1;$/;"	m	struct:state_changer::__anon1	access:public
info5	lsd_handler.h	/^		u_int8_t info5 : 1;$/;"	m	struct:state_changer::__anon1	access:public
info6	lsd_handler.h	/^		u_int8_t info6 : 1;$/;"	m	struct:state_changer::__anon1	access:public
infodir	Makefile	/^infodir = ${datarootdir}\/info$/;"	m
install_sh	Makefile	/^install_sh = ${SHELL} \/home\/macro\/workspace\/pma\/install-sh$/;"	m
install_sh_DATA	Makefile	/^install_sh_DATA = $(install_sh) -c -m 644$/;"	m
install_sh_PROGRAM	Makefile	/^install_sh_PROGRAM = $(install_sh) -c$/;"	m
install_sh_SCRIPT	Makefile	/^install_sh_SCRIPT = $(install_sh) -c$/;"	m
interface	lsd_exchange.h	/^	struct backbone_eth* interface;$/;"	m	struct:exchange_master	typeref:struct:exchange_master::backbone_eth	access:public
interface	lsd_flood.h	/^	struct backbone_eth* interface;$/;"	m	struct:flood_master	typeref:struct:flood_master::backbone_eth	access:public
interface	lsd_if.h	/^    struct rinterface * interface; \/\/the detail infomation of the interface$/;"	m	struct:backbone_eth	typeref:struct:backbone_eth::rinterface	access:public
interface	lsd_if.h	/^    struct rinterface* interface;$/;"	m	struct:access_eth	typeref:struct:access_eth::rinterface	access:public
interface_down	lsd_if.c	/^int interface_down (struct thread* thread){$/;"	f	signature:(struct thread* thread)
interface_down	lsd_if.h	/^int interface_down(struct thread *thread);$/;"	p	signature:(struct thread *thread)
interface_up	lsd_if.c	/^int interface_up(struct thread* thread){$/;"	f	signature:(struct thread* thread)
interface_up	lsd_if.h	/^int interface_up(struct thread *thread); $/;"	p	signature:(struct thread *thread)
iov_count	lsd_socket.c	/^int iov_count(struct iovec *iov) {$/;"	f	signature:(struct iovec *iov)
iov_totallen	lsd_socket.c	/^int iov_totallen(struct iovec *iov) {$/;"	f	signature:(struct iovec *iov)
is_keys_equals	lsd_utils.c	/^int is_keys_equals(const struct link_state_key* key1, const struct link_state_key* key2)$/;"	f	signature:(const struct link_state_key* key1, const struct link_state_key* key2)
is_out_of_date	lsd_utils.c	/^int is_out_of_date(const struct cr_lsdb_link_state* old)$/;"	f	signature:(const struct cr_lsdb_link_state* old)
is_out_of_date	lsd_utils.h	/^int is_out_of_date(const struct cr_lsdb_link_state* old);$/;"	p	signature:(const struct cr_lsdb_link_state* old)
l_dead_val	lsd_hello.h	/^	u32 l_dead_val;$/;"	m	struct:hello_master	access:public
l_hello_val	lsd_hello.h	/^	u32 l_hello_val;$/;"	m	struct:hello_master	access:public
length	lsd_exchange.h	/^	u16 length;$/;"	m	struct:exchange	access:public
libdir	Makefile	/^libdir = ${exec_prefix}\/lib$/;"	m
libexecdir	Makefile	/^libexecdir = ${exec_prefix}\/libexec$/;"	m
libpmalsd_a_AR	Makefile	/^libpmalsd_a_AR = $(AR) $(ARFLAGS)$/;"	m
libpmalsd_a_LIBADD	Makefile	/^libpmalsd_a_LIBADD =$/;"	m
libpmalsd_a_OBJECTS	Makefile	/^libpmalsd_a_OBJECTS = $(am_libpmalsd_a_OBJECTS)$/;"	m
libpmalsd_a_SOURCES	Makefile	/^libpmalsd_a_SOURCES = lsdsrv.c\\$/;"	m
lidb	lsd_if.h	/^     id_t lidb; \/\/lidb of the area \/\/2013.04.09  not used in ic$/;"	m	struct:autonomous_zone	access:public
lidb_get_eth_handle	lsd_if.h	91;"	d
link_lsa_received	lsd_exchange.c	/^void link_lsa_received(struct exchange *ex_header, struct backbone_eth* bb_link)$/;"	f	signature:(struct exchange *ex_header, struct backbone_eth* bb_link)
link_lsa_received	lsd_exchange.c	/^void link_lsa_received(struct exchange *ex_header, struct backbone_eth* bb_link);$/;"	p	file:	signature:(struct exchange *ex_header, struct backbone_eth* bb_link)
link_state_compare	lsd_utils.c	/^int link_state_compare(const struct cr_lsdb_link_state* state1, const struct cr_lsdb_link_state* state2)$/;"	f	signature:(const struct cr_lsdb_link_state* state1, const struct cr_lsdb_link_state* state2)
link_state_compare	lsd_utils.h	/^int link_state_compare(const struct cr_lsdb_link_state* state1, const struct cr_lsdb_link_state* state2);$/;"	p	signature:(const struct cr_lsdb_link_state* state1, const struct cr_lsdb_link_state* state2)
links_state	lsd_exchange.h	/^	struct cr_lsdb_link_state* links_state;$/;"	m	struct:exchange_master	typeref:struct:exchange_master::cr_lsdb_link_state	access:public
localedir	Makefile	/^localedir = ${datarootdir}\/locale$/;"	m
localstatedir	Makefile	/^localstatedir = ${prefix}\/var$/;"	m
low_status	lsd_hello.h	/^	enum lsd_status low_status;$/;"	m	struct:hello_master	typeref:enum:hello_master::lsd_status	access:public
lsa	lsd_flood.h	/^	struct link_state_adv lsa;$/;"	m	struct:flood_snd_item	typeref:struct:flood_snd_item::link_state_adv	access:public
lsa_compare	lsd_utils.c	/^int lsa_compare(const struct link_state_adv* lsa1, const struct link_state_adv* lsa2)$/;"	f	signature:(const struct link_state_adv* lsa1, const struct link_state_adv* lsa2)
lsa_to_lsdb_info	lsd_utils.c	/^void lsa_to_lsdb_info(const struct link_state_adv* lsa, struct cr_lsdb_link_state* lsdb)$/;"	f	signature:(const struct link_state_adv* lsa, struct cr_lsdb_link_state* lsdb)
lsa_to_lsdb_info	lsd_utils.h	/^void lsa_to_lsdb_info(const struct link_state_adv* lsa, struct cr_lsdb_link_state* lsdb);$/;"	p	signature:(const struct link_state_adv* lsa, struct cr_lsdb_link_state* lsdb)
lsd_h_sock	lsd_socket.c	/^int lsd_h_sock;$/;"	v
lsd_hd	lsd_exchange.h	/^	struct lsd_head lsd_hd;$/;"	m	struct:exchange	typeref:struct:exchange::lsd_head	access:public
lsd_hd	lsd_flood.h	/^	struct lsd_head lsd_hd;$/;"	m	struct:flood	typeref:struct:flood::lsd_head	access:public
lsd_head	lsd_hello.h	/^	struct lsd_head lsd_head;$/;"	m	struct:hello_high	typeref:struct:hello_high::lsd_head	access:public
lsd_head	lsd_hello.h	/^	struct lsd_head lsd_head;$/;"	m	struct:hello_low	typeref:struct:hello_low::lsd_head	access:public
lsd_head	lsd_socket.h	/^struct lsd_head$/;"	s
lsd_head::area_id	lsd_socket.h	/^	u32 area_id;$/;"	m	struct:lsd_head	access:public
lsd_head::icsum	lsd_socket.h	/^	u32 icsum;$/;"	m	struct:lsd_head	access:public
lsd_head::if_id	lsd_socket.h	/^	u32 if_id;$/;"	m	struct:lsd_head	access:public
lsd_head::pklen	lsd_socket.h	/^	u16 pklen;$/;"	m	struct:lsd_head	access:public
lsd_head::pktype	lsd_socket.h	/^	u8 pktype;$/;"	m	struct:lsd_head	access:public
lsd_head::r_id	lsd_socket.h	/^	u32 r_id;$/;"	m	struct:lsd_head	access:public
lsd_head::version	lsd_socket.h	/^	u8 version;$/;"	m	struct:lsd_head	access:public
lsd_iflist_init	lsd_if.c	/^int lsd_iflist_init()$/;"	f
lsd_init	lsdsrv.c	/^int lsd_init()$/;"	f
lsd_init	lsdsrv.h	/^int lsd_init();$/;"	p	signature:()
lsd_is_connected	lsd_hello.h	/^int lsd_is_connected(const struct lsdb_link_state* const lsa, id_t lsdb_handle);$/;"	p	signature:(const struct lsdb_link_state* const lsa, id_t lsdb_handle)
lsd_l_sock	lsd_socket.c	/^int lsd_l_sock;$/;"	v
lsd_neighbor_info	lsd_hello.h	/^struct lsd_neighbor_info$/;"	s
lsd_neighbor_info::if_id	lsd_hello.h	/^	u32 if_id;$/;"	m	struct:lsd_neighbor_info	access:public
lsd_neighbor_info::rt_id	lsd_hello.h	/^	u32 rt_id;$/;"	m	struct:lsd_neighbor_info	access:public
lsd_receive	lsd_socket.c	/^int lsd_receive (struct thread *thread)$/;"	f	signature:(struct thread *thread)
lsd_receive	lsd_socket.h	/^int lsd_receive (struct thread *thread);$/;"	p	signature:(struct thread *thread)
lsd_recvmsg	lsd_socket.c	/^int lsd_recvmsg(struct in_addr *src, struct in_addr *dst,$/;"	f	signature:(struct in_addr *src, struct in_addr *dst, unsigned int *ifindex, struct iovec *message, int sockfd)
lsd_router	lsd_if.h	/^struct lsd_router \/\/we use this struct to record the area and access interface $/;"	s
lsd_router::accesses	lsd_if.h	/^     struct access_eth* accesses;$/;"	m	struct:lsd_router	typeref:struct:lsd_router::access_eth	access:public
lsd_router::azs	lsd_if.h	/^     struct autonomous_zone* azs; \/\/$/;"	m	struct:lsd_router	typeref:struct:lsd_router::autonomous_zone	access:public
lsd_send	lsd_socket.c	/^int lsd_send (struct backbone_eth* eth,struct lsd_head *head)$/;"	f	signature:(struct backbone_eth* eth,struct lsd_head *head)
lsd_send	lsd_socket.h	/^int lsd_send (struct backbone_eth* eth,struct lsd_head *head);$/;"	p	signature:(struct backbone_eth* eth,struct lsd_head *head)
lsd_sendmsg	lsd_socket.c	/^int lsd_sendmsg(struct in_addr *src, struct in_addr *dst,$/;"	f	signature:(struct in_addr *src, struct in_addr *dst, unsigned int *ifindex, struct iovec *message)
lsd_serv_sock	lsd_socket.c	/^int lsd_serv_sock(){$/;"	f
lsd_serv_sock	lsd_socket.h	/^int lsd_serv_sock();$/;"	p	signature:()
lsd_start	lsdsrv.c	/^int lsd_start()$/;"	f
lsd_start	lsdsrv.h	/^int lsd_start();$/;"	p	signature:()
lsd_status	lsd_hello.h	/^enum lsd_status$/;"	g
lsdb	lsd_if.h	/^     id_t lsdb; \/\/ lsdb of the area$/;"	m	struct:autonomous_zone	access:public
lsdb_get_area_handle	lsd_if.h	92;"	d
lsdb_get_eth_handle	lsd_if.h	90;"	d
lsdb_to_lsa_info	lsd_utils.c	/^void lsdb_to_lsa_info(const struct cr_lsdb_link_state* lsdb, struct link_state_adv* lsa)$/;"	f	signature:(const struct cr_lsdb_link_state* lsdb, struct link_state_adv* lsa)
lsdb_to_lsa_info	lsd_utils.h	/^void lsdb_to_lsa_info(const struct cr_lsdb_link_state* lsdb, struct link_state_adv* lsa);$/;"	p	signature:(const struct cr_lsdb_link_state* lsdb, struct link_state_adv* lsa)
mandir	Makefile	/^mandir = ${datarootdir}\/man$/;"	m
master	lsdsrv.c	/^struct thread_master *master;$/;"	v	typeref:struct:thread_master
mkdir_p	Makefile	/^mkdir_p = $(MKDIR_P)$/;"	m
mkinstalldirs	Makefile	/^mkinstalldirs = $(install_sh) -d$/;"	m
more	lsd_exchange.h	/^	u8 more;$/;"	m	struct:exchange	access:public
neighbor	lsd_hello.h	/^	struct lsd_neighbor_info neighbor;$/;"	m	struct:hello_master	typeref:struct:hello_master::lsd_neighbor_info	access:public
neighbor_pma	lsd_if.h	/^    struct neighbor_pma neighbor_pma; $/;"	m	struct:backbone_eth	typeref:struct:backbone_eth::neighbor_pma	access:public
neighbor_pma	lsd_if.h	/^struct neighbor_pma{$/;"	s
neighbor_pma::pma_ctl_addr	lsd_if.h	/^    struct in_addr pma_ctl_addr;$/;"	m	struct:neighbor_pma	typeref:struct:neighbor_pma::in_addr	access:public
neighbor_pma::rid	lsd_if.h	/^    u32 rid;$/;"	m	struct:neighbor_pma	access:public
neighbor_pma::router_addr	lsd_if.h	/^    struct in_addr router_addr;$/;"	m	struct:neighbor_pma	typeref:struct:neighbor_pma::in_addr	access:public
next	lsd_if.h	/^     struct autonomous_zone* next; $/;"	m	struct:autonomous_zone	typeref:struct:autonomous_zone::autonomous_zone	access:public
next	lsd_if.h	/^    struct access_eth* next;$/;"	m	struct:access_eth	typeref:struct:access_eth::access_eth	access:public
next	lsd_if.h	/^    struct backbone_eth* next; \/\/next interface$/;"	m	struct:backbone_eth	typeref:struct:backbone_eth::backbone_eth	access:public
noinst_HEADERS	Makefile	/^noinst_HEADERS = lsdsrv.h lsd_utils.h lsd_socket.h \\$/;"	m
noinst_LIBRARIES	Makefile	/^noinst_LIBRARIES = libpmalsd.a$/;"	m
oldincludedir	Makefile	/^oldincludedir = \/usr\/include$/;"	m
on_exchange_finished	lsd_handler.h	/^void on_exchange_finished(struct backbone_eth* eth);$/;"	p	signature:(struct backbone_eth* eth)
pdfdir	Makefile	/^pdfdir = ${docdir}$/;"	m
periodctrl	lsd_flood.c	/^struct thread* periodctrl = NULL;$/;"	v	typeref:struct:thread
pkg_no	lsd_exchange.h	/^	u32 pkg_no;$/;"	m	struct:exchange_master	access:public
pkg_no	lsd_flood.h	/^	u32 pkg_no;$/;"	m	struct:flood_master	access:public
pkgdatadir	Makefile	/^pkgdatadir = $(datadir)\/pma$/;"	m
pkgincludedir	Makefile	/^pkgincludedir = $(includedir)\/pma$/;"	m
pkglibdir	Makefile	/^pkglibdir = $(libdir)\/pma$/;"	m
pkglibexecdir	Makefile	/^pkglibexecdir = $(libexecdir)\/pma$/;"	m
pklen	lsd_socket.h	/^	u16 pklen;$/;"	m	struct:lsd_head	access:public
pkt_rcv_handler	lsd_event.h	/^typedef void (*pkt_rcv_handler)(struct backbone_eth* link,struct lsd_head* head);$/;"	t
pkt_rcv_queue	lsd_event.c	/^define_event_queue(pkt_rcv_queue);$/;"	v
pkt_rcv_queue	lsd_socket.c	/^declare_event_queue(pkt_rcv_queue); $/;"	v
pktype	lsd_socket.h	/^	u8 pktype;$/;"	m	struct:lsd_head	access:public
pma_ctl_addr	lsd_if.h	/^    struct in_addr pma_ctl_addr;$/;"	m	struct:neighbor_pma	typeref:struct:neighbor_pma::in_addr	access:public
prefix	Makefile	/^prefix = \/usr\/local$/;"	m
priority_type	lsd_hello.h	/^enum priority_type$/;"	g
program_transform_name	Makefile	/^program_transform_name = s,x,x,$/;"	m
psdir	Makefile	/^psdir = ${docdir}$/;"	m
ptrs	lsd_flood.h	/^	struct cr_list_head ptrs;$/;"	m	struct:flood_snd_item	typeref:struct:flood_snd_item::cr_list_head	access:public
queue	lsd_flood.h	/^	struct cr_list_head queue;$/;"	m	struct:flood_master	typeref:struct:flood_master::cr_list_head	access:public
r_id	lsd_if.h	/^     u32 r_id;  \/\/routerid exposed to the area$/;"	m	struct:autonomous_zone	access:public
r_id	lsd_socket.h	/^	u32 r_id;$/;"	m	struct:lsd_head	access:public
rcv_ctrl	lsd_exchange.h	/^	struct thread* rcv_ctrl;$/;"	m	struct:exchange_master	typeref:struct:exchange_master::thread	access:public
rcv_state	lsd_exchange.h	/^	enum exchange_rcv_state rcv_state;$/;"	m	struct:exchange_master	typeref:enum:exchange_master::exchange_rcv_state	access:public
rcv_time_excceed	lsd_exchange.h	/^int rcv_time_excceed (struct thread *thread);$/;"	p	signature:(struct thread *thread)
recvbuf	lsd_socket.c	/^char recvbuf[MAX_MESSAGE_LEN];$/;"	v
retry_times	lsd_exchange.h	/^	int retry_times;$/;"	m	struct:exchange_master	access:public
rid	lsd_if.h	/^    u32 rid;$/;"	m	struct:neighbor_pma	access:public
router_addr	lsd_if.h	/^    struct in_addr router_addr;$/;"	m	struct:neighbor_pma	typeref:struct:neighbor_pma::in_addr	access:public
rt_id	lsd_hello.h	/^	u32 rt_id;$/;"	m	struct:lsd_neighbor_info	access:public
sbindir	Makefile	/^sbindir = ${exec_prefix}\/sbin$/;"	m
send_state	lsd_exchange.h	/^	enum exchange_send_state send_state;$/;"	m	struct:exchange_master	typeref:enum:exchange_master::exchange_send_state	access:public
sendbuf	lsd_exchange.h	/^	char sendbuf[MAX_EXCHANGE_BUF_LEN];$/;"	m	struct:exchange_master	access:public
sendbuf	lsd_flood.h	/^	char sendbuf[MAX_FLOOD_BUF_LEN];$/;"	m	struct:flood_master	access:public
sendbuf	lsd_hello.c	/^char sendbuf[MAX_MESSAGE_LEN];$/;"	v
seq	lsd_exchange.h	/^	u32 seq;$/;"	m	struct:exchange	access:public
seq	lsd_flood.h	/^	u32 seq;$/;"	m	struct:flood	access:public
sharedstatedir	Makefile	/^sharedstatedir = ${prefix}\/com$/;"	m
show_if_info	lsd_if.c	/^int show_if_info(struct common_eth * eth)$/;"	f	signature:(struct common_eth * eth)
size	lsd_flood.h	/^	u32 size;$/;"	m	struct:flood	access:public
snd_ctrl	lsd_flood.h	/^	struct thread* snd_ctrl;$/;"	m	struct:flood_master	typeref:struct:flood_master::thread	access:public
spread_local_link_state	lsd_flood.c	/^int spread_local_link_state(struct thread* t)$/;"	f	signature:(struct thread* t)
srcdir	Makefile	/^srcdir = .$/;"	m
state	lsd_flood.h	/^	enum flood_state state;$/;"	m	struct:flood_master	typeref:enum:flood_master::flood_state	access:public
state	lsd_if.h	/^    enum eth_state state;$/;"	m	struct:common_eth	typeref:enum:common_eth::eth_state	access:public
state_changer	lsd_handler.h	/^typedef union state_changer$/;"	u
state_changer	lsd_handler.h	/^}state_changer;$/;"	t	typeref:union:state_changer
state_changer::__anon1::hello_high	lsd_handler.h	/^		u_int8_t hello_high : 1;$/;"	m	struct:state_changer::__anon1	access:public
state_changer::__anon1::hello_low	lsd_handler.h	/^		u_int8_t hello_low : 1;$/;"	m	struct:state_changer::__anon1	access:public
state_changer::__anon1::info1	lsd_handler.h	/^		u_int8_t info1 : 1;$/;"	m	struct:state_changer::__anon1	access:public
state_changer::__anon1::info2	lsd_handler.h	/^		u_int8_t info2 : 1;$/;"	m	struct:state_changer::__anon1	access:public
state_changer::__anon1::info3	lsd_handler.h	/^		u_int8_t info3 : 1;$/;"	m	struct:state_changer::__anon1	access:public
state_changer::__anon1::info4	lsd_handler.h	/^		u_int8_t info4 : 1;$/;"	m	struct:state_changer::__anon1	access:public
state_changer::__anon1::info5	lsd_handler.h	/^		u_int8_t info5 : 1;$/;"	m	struct:state_changer::__anon1	access:public
state_changer::__anon1::info6	lsd_handler.h	/^		u_int8_t info6 : 1;$/;"	m	struct:state_changer::__anon1	access:public
state_changer::data	lsd_handler.h	/^	u_int8_t data;$/;"	m	union:state_changer	access:public
state_changer::field	lsd_handler.h	/^	}field;$/;"	m	union:state_changer	typeref:struct:state_changer::__anon1	access:public
subdir	Makefile	/^subdir = lsd$/;"	m
sysconfdir	Makefile	/^sysconfdir = ${prefix}\/etc$/;"	m
target_alias	Makefile	/^target_alias = $/;"	m
top_build_prefix	Makefile	/^top_build_prefix = ..\/$/;"	m
top_builddir	Makefile	/^top_builddir = ..$/;"	m
top_srcdir	Makefile	/^top_srcdir = ..$/;"	m
topology_queue	lsd_hello.c	/^declare_event_queue(topology_queue);$/;"	v
transform	Makefile	/^transform = $(program_transform_name)$/;"	m
type	lsd_exchange.h	/^	u8 type;$/;"	m	struct:exchange	access:public
type	lsd_flood.h	/^	u8 type;$/;"	m	struct:flood	access:public
type	lsd_if.h	/^    enum eth_type type;$/;"	m	struct:common_eth	typeref:enum:common_eth::eth_type	access:public
version	lsd_socket.h	/^	u8 version;$/;"	m	struct:lsd_head	access:public
